---
description: Xcode项目（iOS、macOS、iPadOS）都需要使用mvvm架构，符合SwiftUI响应式布局，Combine响应式编程。一切都需要符合swiftUI最佳实践！
alwaysApply: true
---

# 最佳实践指南：SwiftUI响应式布局 + MVVM架构 + Combine响应式编程

## 项目架构要求

### 核心技术栈
- **架构模式**: MVVM (Model-View-ViewModel)
- **UI框架**: SwiftUI (iOS17+, iPadOS17+, macOS14+)
- **响应式编程**: Combine
- **数据持久化**: SwiftData
- **语言版本**: Swift 6.1+

### 平台支持
- iOS 17.0+
- iPadOS 17.0+
- macOS 14.0+

## MVVM架构规范

### 1. Models (数据模型)
- 纯数据结构，不包含业务逻辑
- 使用 `@Model` 宏用于 SwiftData
- 只包含属性和简单的数据处理方法
- 不直接引用 SwiftUI 或 Combine

### 2. ViewModels (视图模型)
- 处理业务逻辑，管理状态
- 使用 `@Observable` 宏 (iOS17+/macOS14+)
- 包含 `@Published` 属性用于状态管理
- 不直接引用 SwiftUI Views
- 禁止使用单例模式
- 使用 Combine 进行响应式数据流处理

#### ViewModel响应式编程规范
- 所有需要触发UI更新的属性必须标记为 `@Published`
- 依赖 `@Published` 属性的计算属性会自动响应变化
- 使用 Combine 操作符 (map, filter, etc.) 处理复杂数据流
- 使用 `Set<AnyCancellable>` 管理订阅生命周期
- 避免手动调用 `objectWillChange.send()`

### 3. Views (视图)
- 纯UI展示，不包含业务逻辑
- 使用 SwiftUI 开发
- 通过 `@State` 和 `@Bindable` 管理状态
- 使用 ViewModel 处理业务逻辑
- 组件化、可复用
- 支持多平台适配

## 代码组织与职责分离

### 文件结构
```
Feature/
├── Views/
│   ├── FeatureView.swift
│   └── Components/
├── ViewModels/
│   └── FeatureViewModel.swift
├── Models/
│   └── FeatureModel.swift
└── Services/
    └── FeatureService.swift
```

### 职责分离原则
- **Views**: 只负责UI展示和用户交互响应
- **ViewModels**: 处理业务逻辑、数据转换、状态管理
- **Models**: 数据结构定义和简单数据处理
- **Services**: 网络请求、数据存储等基础设施逻辑

## SwiftUI最佳实践

### 响应式布局
- 优先使用 SwiftUI 内置的响应式布局系统
- 合理使用 Size Classes 进行设备适配
- 避免过度使用 GeometryReader
- 使用 ScrollView 优化长内容展示

### 状态管理
```swift
// ✅ 正确：按需创建ViewModel
struct FeatureView: View {
    @State private var viewModel = FeatureViewModel()
    
    var body: some View {
        ContentView()
            .environment(viewModel)
    }
}

// ✅ 正确：响应式ViewModel
@Observable
class FeatureViewModel {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        $items
            .map { items in
                items.map { transformItem($0) }
            }
            .sink { [weak self] transformedItems in
                // 处理转换后的数据
            }
            .store(in: &cancellables)
    }
}
```

### 组件化开发
- 每个组件职责单一
- 组件可复用、可测试
- 合理使用 ViewModifier 和 ViewBuilder
- 避免过深层次的视图嵌套

## Combine响应式编程

### 数据流处理
```swift
class ViewModel: ObservableObject {
    @Published var searchText = ""
    @Published var searchResults: [Item] = []
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        $searchText
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .removeDuplicates()
            .flatMap { text in
                text.isEmpty ? Just([]).eraseToAnyPublisher() : 
                self.searchService.search(text).catch { _ in Just([]) }.eraseToAnyPublisher()
            }
            .assign(to: &$searchResults)
    }
}
```

### 错误处理
- 使用 `catch` 操作符处理错误
- 统一错误处理机制
- 避免在 View 层处理复杂错误逻辑

## 禁止事项

### 架构层面
- ❌ 在 View 中直接处理业务逻辑
- ❌ 在 Model 中包含业务逻辑
- ❌ 使用单例模式创建 ViewModel
- ❌ 多个 View 共享同一个 ViewModel 实例
- ❌ 在 ViewModel 中直接操作 UI

### 代码实现
- ❌ 手动计算屏幕尺寸和比例
- ❌ 使用固定像素值布局
- ❌ 复杂的 GeometryReader 嵌套
- ❌ 忽略内存管理 (忘记调用 store(in:))

## 性能优化

### 响应式数据流
- 合理使用 `@Published` 避免不必要的更新
- 使用 `removeDuplicates()` 减少重复计算
- 使用 `debounce()` 优化用户输入响应

### 视图渲染
- 避免在 `body` 中进行复杂计算
- 使用 `@State` 和 `@Binding` 优化状态传递
- 合理使用 `@ViewBuilder` 优化视图构建

## 测试与维护

### 可测试性
- ViewModel 应该易于单元测试
- 业务逻辑与 UI 逻辑分离
- 使用依赖注入便于测试

### 代码质量
- 遵循 Swift 命名规范
- 保持函数和类的职责单一
- 添加必要的注释和文档