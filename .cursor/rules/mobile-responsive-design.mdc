---
description: iOS17+ 现代响应式设计规范 - 基于最新SwiftUI特性的简洁高效布局方案
alwaysApply: true
---
# 📱 iOS17+ 现代响应式设计规范

**目标系统**: iOS17+, iPadOS17+ (不考虑更低版本)
**核心理念**: 简洁、现代、高效 - 充分利用最新SwiftUI特性

## 🎯 核心原则

### 1. 优先使用现代SwiftUI特性
- **Size Classes** - 替代复杂的设备检测
- **ScrollView** - 替代复杂的GeometryReader布局
- **Environment Values** - 响应系统设置变化
- **Dynamic Type** - 系统级字体缩放支持

### 2. 禁止过度工程化
- ❌ **禁止**自定义设备适配工具类
- ❌ **禁止**复杂的GeometryReader嵌套
- ❌ **禁止**手动计算屏幕尺寸
- ❌ **禁止**固定像素值布局
- ❌ **禁止**错误使用ViewThatFits (详见横屏适配章节)

## 🏗️ 现代布局架构

### 基础响应式模板
```swift
struct ModernResponsiveView: View {
    // MARK: - Environment
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
    @Environment(\.verticalSizeClass) private var verticalSizeClass

    var body: some View {
        ScrollView {
            VStack(spacing: adaptiveSpacing) {
                Spacer(minLength: topSpacing)

                // 内容组件
                contentView

                Spacer(minLength: bottomSpacing)
            }
            .padding(.horizontal, horizontalPadding)
            .frame(maxWidth: .infinity)
        }
    }
}

// MARK: - Adaptive Properties
private extension ModernResponsiveView {
    var isCompact: Bool {
        horizontalSizeClass == .compact
    }

    var isLandscape: Bool {
        verticalSizeClass == .compact
    }

    var adaptiveSpacing: CGFloat { isCompact ? 16 : 24 }
    var topSpacing: CGFloat { isCompact ? 20 : 40 }
    var bottomSpacing: CGFloat { isCompact ? 20 : 40 }
    var horizontalPadding: CGFloat { isCompact ? 20 : 40 }
}
```

## 🔤 现代字体系统

### 系统字体样式 (iOS17+)
```swift
// ✅ 推荐：使用系统字体样式
Text("标题").font(.largeTitle)     // 34pt - 页面大标题
Text("标题").font(.title)         // 28pt - 页面标题
Text("标题").font(.title2)        // 22pt - 次要标题
Text("内容").font(.body)          // 17pt - 正文内容
Text("说明").font(.callout)       // 16pt - 说明文字
Text("脚注").font(.footnote)      // 13pt - 脚注
Text("标签").font(.caption)       // 12pt - 图片说明

// ❌ 禁止：固定字体大小
Text("标题").font(.system(size: 28)) // 禁止使用
```

### 动态类型支持
```swift
// ✅ 限制字体大小范围
Text("内容")
    .font(.body)
    .dynamicTypeSize(...DynamicTypeSize.accessibility1) // 限制最大字体

// ✅ 响应动态类型变化
@Environment(\.dynamicTypeSize) var dynamicTypeSize

var adaptiveFont: Font {
    dynamicTypeSize.isAccessibilitySize ? .title3 : .body
}
```

### 自定义字体的现代用法
```swift
// ✅ 支持动态类型的自定义字体
Text("内容")
    .font(.custom("STKaiti", size: 18))
    .dynamicTypeSize(...DynamicTypeSize.large) // 限制范围
```

## 📐 Size Classes 响应式设计

### 基础Size Classes判断
```swift
@Environment(\.horizontalSizeClass) private var horizontalSizeClass
@Environment(\.verticalSizeClass) private var verticalSizeClass

// 设备尺寸判断
var isCompact: Bool {
    horizontalSizeClass == .compact
}

// 横竖屏判断 (推荐用于布局切换)
var isLandscape: Bool {
    verticalSizeClass == .compact
}
```

### 两种布局判断策略

#### 1. 横竖屏导向布局 (推荐)
```swift
// ✅ 推荐：基于横竖屏的布局判断
var body: some View {
    if verticalSizeClass == .compact {
        landscapeLayout  // 横屏模式 (所有设备)
    } else {
        portraitLayout   // 竖屏模式
    }
}
```

#### 2. 设备尺寸导向布局
```swift
// ✅ 适用场景：需要区分设备尺寸时
var body: some View {
    if horizontalSizeClass == .compact {
        compactLayout    // iPhone竖屏、iPad分屏
    } else {
        regularLayout    // iPad横屏、大屏iPhone横屏
    }
}
```

### 设备适配策略
- **横竖屏判断**: 统一使用 `verticalSizeClass == .compact` 判断横屏
- **设备尺寸判断**: 使用 `horizontalSizeClass == .compact` 判断紧凑尺寸
- **分屏/多窗口**: 自动适配为 `.compact`

## 📱 设备差异化适配

### 不同设备的Size Classes表现
```swift
// iPhone 14 Pro (标准尺寸)
// 竖屏：horizontalSizeClass=.compact, verticalSizeClass=.regular
// 横屏：horizontalSizeClass=.compact, verticalSizeClass=.compact

// iPhone 14 Pro Max (大屏尺寸)
// 竖屏：horizontalSizeClass=.compact, verticalSizeClass=.regular
// 横屏：horizontalSizeClass=.regular, verticalSizeClass=.compact

// iPad Pro
// 竖屏：horizontalSizeClass=.regular, verticalSizeClass=.regular
// 横屏：horizontalSizeClass=.regular, verticalSizeClass=.compact
```

### 设备差异化响应式属性
```swift
// ✅ 推荐：根据horizontalSizeClass进行设备差异化
private var adaptiveSpacing: CGFloat {
    if isLandscape {
        // 横屏时根据设备调整
        return horizontalSizeClass == .regular ? 40 : 30
    } else {
        // 竖屏时根据设备调整
        return isCompact ? 16 : 24
    }
}

private var adaptiveComponentSize: CGFloat {
    if isLandscape {
        // 大屏设备横屏时可以使用更大的组件
        return horizontalSizeClass == .regular ? 280 : 240
    } else {
        return isCompact ? 200 : 250
    }
}
```

## 🔄 横屏适配最佳实践

### ViewThatFits使用注意事项
```swift
// ❌ 错误：ViewThatFits不适合横屏适配
ViewThatFits(in: .vertical) {
    portraitLayout
    landscapeLayout
}

// ✅ 正确：ViewThatFits适合内容自适应
ViewThatFits {
    // 优先显示完整内容
    HStack { icon; title; description; button }

    // 空间不足时简化
    VStack { icon; title; button }

    // 最小布局
    VStack { title; button }
}
```

### 横屏适配原则
1. **移除ScrollView**：横屏时通常不需要滚动，直接使用HStack
2. **使用HStack**：水平排列主要内容
3. **适当调整尺寸**：横屏组件可以比竖屏稍大，充分利用水平空间
4. **固定高度**：使用`.frame(maxHeight: .infinity)`填满屏幕
5. **简化内容**：必要时隐藏次要元素
6. **竖屏也可无ScrollView**：如果内容适合屏幕，竖屏也可移除ScrollView

## 🎨 现代布局组件

### 布局选择策略
```swift
// ✅ 内容适合屏幕时：直接使用VStack (推荐)
VStack(spacing: adaptiveSpacing) {
    Spacer(minLength: topSpacing)

    // 内容组件
    welcomeIcon
    welcomeText
    actionButton
    hintText

    Spacer(minLength: bottomSpacing)
}
.padding(.horizontal, horizontalPadding)
.frame(maxWidth: .infinity, maxHeight: .infinity)

// ✅ 内容较多时：使用ScrollView + VStack
ScrollView {
    VStack(spacing: adaptiveSpacing) {
        // 内容组件
        welcomeIcon
        welcomeText
        actionButton
        hintText
    }
    .padding(.horizontal, horizontalPadding)
    .frame(maxWidth: .infinity)
}

// ❌ 旧模式 - 复杂且性能差
GeometryReader { geometry in
    VStack(spacing: 0) {
        DeviceAdaptation.responsiveSpacer(...)  // 禁止
        // 复杂的计算逻辑
    }
}
```

### ViewThatFits 自适应布局 (iOS16+)
```swift
// ✅ 自动选择合适的布局
ViewThatFits {
    // 优先显示完整布局
    HStack(spacing: 20) {
        image
        VStack { title; description }
        actionButton
    }

    // 空间不足时的简化布局
    VStack(spacing: 12) {
        image
        title
        actionButton
    }

    // 最小布局
    VStack(spacing: 8) {
        title
        actionButton
    }
}
```

### 响应式间距和尺寸
```swift
// ✅ 基于Size Classes的响应式属性
private extension View {
    var isCompact: Bool { horizontalSizeClass == .compact }
    var isLandscape: Bool { verticalSizeClass == .compact }

    // 竖屏属性
    var portraitSpacing: CGFloat { isCompact ? 16 : 24 }
    var portraitPadding: CGFloat { isCompact ? 20 : 40 }
    var portraitIconSize: CGFloat { isCompact ? 70 : 90 }

    // 横屏属性 (根据设备差异化调整)
    var landscapeSpacing: CGFloat {
        horizontalSizeClass == .regular ? 40 : 30
    }
    var landscapePadding: CGFloat {
        horizontalSizeClass == .regular ? 35 : 25
    }
    var landscapeIconSize: CGFloat {
        horizontalSizeClass == .regular ? 90 : 80  // 大屏设备更大
    }
}

// ✅ 使用系统间距
VStack(spacing: .systemSpacing) { ... }  // iOS17+
HStack(spacing: .systemSpacing) { ... }
```

## 🧩 父子布局职责（父容器掌控尺寸）

### 原则
- **父容器负责空间分配与拉伸**：页面/区块级容器（如 `VStack`、`HStack`、`ZStack`）决定是否使用 `.frame(maxWidth: .infinity, maxHeight: .infinity)`、固定宽度或高度、以及外层 `padding`。
- **子视图尽量不主动抢占空间**：子组件避免在内部使用 `.frame(maxWidth: .infinity, maxHeight: .infinity)` 抢占父容器空间，也避免固定宽高去“布局”父容器。

### 子视图不应该
- 在组件内部使用通用拉伸 `.frame(maxWidth: .infinity, maxHeight: .infinity)` 让自己占满父容器。
- 固定宽高去驱动整体布局（除非组件自身语义需要最小/最大限度，例如占位的最小高度）。
- 通过过多 `.frame` 叠加制造与父容器相冲突的约束。

### 更应该让父视图做
- 在父容器内，对需要铺满或分栏的子项设置 `.frame(maxWidth: .infinity, maxHeight: .infinity)` 或明确的宽/高。
- 父容器统一处理外边距与对齐；子组件只处理内容样式（如 `.aspectRatio(contentMode: .fit)`、内部 `padding`、必要的 `minHeight`）。
- 需要横屏子项填满高度时，在父层对该子项加 `.frame(maxHeight: .infinity)`，而不是在子组件内部加。

### 示例
```swift
// ❌ 子视图内部不应抢占父容器尺寸
struct ImageCard: View {
    var body: some View {
        AsyncImage(/* ... */)
            .aspectRatio(contentMode: .fit)
            // .frame(maxWidth: .infinity, maxHeight: .infinity) // 避免在子组件内部拉满
    }
}

// ✅ 由父视图决定拉伸/分配空间
HStack {
    ImageCard()
        .frame(maxWidth: .infinity, maxHeight: .infinity) // 父层控制

    TextPanel()
        .frame(width: 260)
}
.frame(maxWidth: .infinity, maxHeight: .infinity) // 页面级容器控制
```

### 例外说明
- 组件是页面级/区块级容器本身时，可在内部使用铺满策略（如欢迎页的根容器）。
- 子组件语义需要“稳定性”时可设置 `minHeight` 或 `ideal` 尺寸，避免视觉跳动，但不应随意固定绝对宽高。

## 🔀 双布局系统最佳实践

### 完整的双布局实现
```swift
struct AdaptiveView: View {
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
    @Environment(\.verticalSizeClass) private var verticalSizeClass

    var body: some View {
        ZStack {
            backgroundImage

            if verticalSizeClass == .compact {
                landscapeLayout  // 横屏模式 (所有设备)
            } else {
                portraitLayout   // 竖屏模式
            }
        }
    }
}

// MARK: - Layout Components
private extension AdaptiveView {
    var portraitLayout: some View {
        VStack(spacing: portraitSpacing) {
            Spacer(minLength: portraitTopSpacing)
            portraitTitleText
            Spacer(minLength: portraitMiddleSpacing)
            portraitMainContent
            Spacer(minLength: portraitBottomSpacing)
            portraitActionButton
            Spacer(minLength: portraitEndSpacing)
        }
        .padding(.horizontal, portraitPadding)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    var landscapeLayout: some View {
        HStack(spacing: landscapeSpacing) {
            VStack(spacing: 15) {
                landscapeTitleText
                landscapeMainContent
            }
            .frame(maxWidth: .infinity)

            VStack {
                Spacer()
                landscapeActionButton
                Spacer()
            }
            .frame(width: landscapeButtonAreaWidth)
        }
        .padding(.horizontal, landscapePadding)
        .padding(.vertical, 10)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// MARK: - Adaptive Properties
private extension AdaptiveView {
    var isCompact: Bool { horizontalSizeClass == .compact }

    // 竖屏属性
    var portraitSpacing: CGFloat { isCompact ? 16 : 24 }
    var portraitTopSpacing: CGFloat { isCompact ? 20 : 40 }
    var portraitMiddleSpacing: CGFloat { isCompact ? 30 : 50 }
    var portraitBottomSpacing: CGFloat { isCompact ? 40 : 60 }
    var portraitEndSpacing: CGFloat { isCompact ? 20 : 40 }
    var portraitPadding: CGFloat { isCompact ? 20 : 40 }
    var portraitContentSize: CGFloat { isCompact ? 280 : 350 }

    // 横屏属性 (根据设备差异化调整)
    var landscapeSpacing: CGFloat {
        horizontalSizeClass == .regular ? 40 : 30
    }
    var landscapePadding: CGFloat {
        horizontalSizeClass == .regular ? 35 : 25
    }
    var landscapeContentSize: CGFloat {
        horizontalSizeClass == .regular ? 280 : 240
    }
    var landscapeButtonAreaWidth: CGFloat {
        horizontalSizeClass == .regular ? 260 : 220
    }
}
```

## ⚠️ 禁止事项

### 绝对禁止
- ❌ 创建自定义设备适配工具类 (如 `DeviceAdaptation`)
- ❌ 使用 `UIDevice.current` 检测设备类型
- ❌ 手动计算屏幕尺寸和比例
- ❌ 使用固定像素值 (如 `width: 350`)
- ❌ 复杂的 `GeometryReader` 嵌套
- ❌ 自定义文字高度缓存类
- ❌ 错误使用 `ViewThatFits(in: .vertical)` 进行横屏适配
- ❌ 横屏时仍使用ScrollView导致内容超出屏幕
- ❌ 横屏组件过小，浪费水平空间
- ❌ 竖屏内容适合时仍强制使用ScrollView

### 性能禁忌
- ❌ 过度使用 `GeometryReader`
- ❌ 在视图中进行复杂计算
- ❌ 忽略 `@Environment` 的性能优势
- ❌ 横屏时使用过大的组件尺寸

## 📚 Apple官方文档
- [Human Interface Guidelines - Layout](https://developer.apple.com/design/human-interface-guidelines/layout)
- [SwiftUI Size Classes](https://developer.apple.com/documentation/swiftui/environmentvalues/horizontalsizeclass)
- [Dynamic Type](https://developer.apple.com/documentation/uikit/uifont/scaling_fonts_automatically)
